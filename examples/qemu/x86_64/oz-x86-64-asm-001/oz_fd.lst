     1                                  ; OZ - A more utopian OS
     2                                  ; ex: set expandtab softtabstop=4 shiftwidth=4 nowrap :
     3                                  ;
     4                                  ;
     5                                  ;       x86-64 startup 
     6                                  ;
     7                                  ;
     8                                  ; usage:
     9                                  ;	$ qemu-system-x86_64 -boot a -fda oz_fd -monitor stdio
    10                                  ;
    11                                  ; requires: nasm-2.07  or later from: http://www.nasm.us
    12                                  ;
    13                                  ; credits:
    14                                  ;       many thanks to the folks at wiki.osdev.org who archive great info.
    15                                  ;       http://wiki.osdev.org/Entering_Long_Mode_Directly
    16                                  ;
    17                                  ; contributors:
    18                                  ;        djv - Duane Voth
    19                                  ;
    20                                  ; history:
    21                                  ; 2015/10/12 - 0.00.64 - djv - dup oz-x86-32-asm-001, get into 64bit mode
    22                                  
    23                                  %ifdef USB
    24                                  [map symbols oz_usb.map]
    25                                  %else
    26                                  [map symbols oz_fd.map]
    27                                  %endif
    28                                  
    29                                  ; -------- stage 1 ---------------------------------------------------------
    30                                  ; A classic x86 Master Boot Record
    31                                  
    32                                  section .text start=0x7c00  ; PC BIOS boot loader entry point
    33                                  codestart :
    34                                  
    35                                  bios_entry :
    36 00000000 FA                          cli
    37 00000001 EA[0C00]0000                jmp 0:main              ; load cs, skip over mbr data struct
    38                                  
    39                                  times 6-($-$$)  db 0
    40 00000006 6F7A                    oemid db "oz"
    41                                  
    42 00000008 00<rept>                times 11-($-$$)  db 0
    43                                  
    44                                  ; compute the size of the kernel image in 512 byte sectors
    45                                  nsectors equ codesize/512
    46                                  
    47                                  ; -------- protected-mode support functions --------
    48                                  ;bits 32
    49                                  
    50                                  ;align 4
    51                                  ;IRQA equ 32                 ; system timer interrupt (after remap)
    52                                  ;int_handler_timer :
    53                                  ;    mov  ax,videosel        ; point gs at video memory
    54                                  ;    mov  gs,ax
    55                                  ;    mov  bl,byte [gs:1]     ; inc the color of the first two chars
    56                                  ;    inc  bl
    57                                  ;    and  bl,0xf             ; just the foreground
    58                                  ;    mov  byte [gs:1],bl
    59                                  ;    mov  byte [gs:3],bl
    60                                  ;    mov  al,0x20
    61                                  ;    out  0x20,al            ; signal end of interrupt (eoi)
    62                                  ;    iret
    63                                  
    64                                  ;F - white
    65                                  ;E - yellow
    66                                  ;D - magenta
    67                                  ;C - red
    68                                  ;B - cyan
    69                                  ;A - green
    70                                  ;9 - blue
    71                                  ;8 - dark grey
    72                                  
    73                                  ;align 4
    74                                  ;IRQB equ 33                 ; keyboard interrupt (after remap)
    75                                  ;int_handler_kbd :
    76                                  ;    cli
    77                                  ;    mov  al,0x20
    78                                  ;    out  0x20,al            ; signal end of interrupt (eoi)
    79                                  ;    iret
    80                                  
    81                                  ; -------- main (enter protected mode) --------
    82                                  bits 16
    83 0000000B 90                      align 2
    84                                  
    85                                  main :
    86 0000000C B80070                      mov  ax,kstack_loc
    87 0000000F 89C4                        mov  sp,ax
    88 00000011 31C0                        xor  ax,ax
    89 00000013 8ED0                        mov  ss,ax
    90 00000015 8EC0                        mov  es,ax
    91 00000017 8ED8                        mov  ds,ax
    92 00000019 8EE0                        mov  fs,ax
    93 0000001B 8EE8                        mov  gs,ax
    94 0000001D FC                          cld
    95                                  
    96 0000001E 52                          push dx                 ; save BIOS drive number
    97                                  
    98 0000001F B80006                      mov  ax,0x0600          ; ah=06h : scroll window up, if al = 0 clrscr
    99 00000022 B90000                      mov  cx,0x0000          ; clear window from 0,0 
   100 00000025 BA4F17                      mov  dx,0x174f          ; to 23,79
   101 00000028 B70F                        mov  bh,0xf             ; fill with hi white
   102 0000002A CD10                        int  0x10               ; clear screen for direct writes to video memory
   103                                  
   104 0000002C BE[2400]                    mov  si,bootmsg
   105 0000002F 31DB                        xor  bx,bx
   106 00000031 E81101                      call puts_vga_rm
   107                                                              ; puts_vga_rm leaves gs pointing at video mem
   108 00000034 65C60601000E                mov  byte [gs:1],0xE    ; turn the first two chars yellow
   109 0000003A 65C60603000E                mov  byte [gs:3],0xE
   110                                  
   111                                      ; re-program the 8259's to move the hardware vectors
   112                                      ; out of the soft int range ... what were people thinking!
   113                                  
   114                                  ;    mov  al,0x11
   115                                  ;    out  0x20,al            ; init the 1st 8259
   116                                  ;    mov  al,0x11
   117                                  ;    out  0xA0,al            ; init the 2nd 8259
   118                                  ;    mov  al,0x20
   119                                  ;    out  0x21,al            ; base the 1st 8259 at 0x20
   120                                  ;    mov  al,0x28
   121                                  ;    out  0xA1,al            ; base the 2nd 8259 at 0x28
   122                                  ;    mov  al,0x04
   123                                  ;    out  0x21,al            ; set 1st 8259 as master
   124                                  ;    mov  al,0x02
   125                                  ;    out  0xA1,al            ; set 2nd 8259 as slave
   126                                  ;    mov  al,0x01
   127                                  ;    out  0x21,al
   128                                  ;    mov  al,0x01
   129                                  ;    out  0xA1,al
   130                                  ;    mov  al,0x00
   131                                  ;    out  0x21,al
   132                                  ;    mov  al,0x00
   133                                  ;    out  0xA1,al
   134                                  
   135                                      ; ---- verify this is a 64bit processor
   136                                  
   137 00000040 669C                        pushfd
   138 00000042 6658                        pop  eax
   139 00000044 6689C3                      mov  ebx,eax
   140 00000047 663500002000                xor  eax,0x200000       ; flip the cpuid test flag
   141 0000004D 6650                        push eax
   142 0000004F 669D                        popfd
   143 00000051 669C                        pushfd
   144 00000053 6658                        pop  eax
   145 00000055 6631D8                      xor  eax,ebx            ; did anything change?
   146 00000058 750B                        jnz  have_cpuid
   147                                  
   148                                  not64 :
   149 0000005A BE[3D00]                    mov  si,no64msg
   150 0000005D 31DB                        xor  bx,bx
   151 0000005F E8E300                      call puts_vga_rm
   152                                  halt :
   153 00000062 F4                          hlt
   154 00000063 EBFD                        jmp  halt               ; we're done
   155                                  
   156                                  have_cpuid :
   157 00000065 6653                        push ebx
   158 00000067 669D                        popfd                   ; restore flags
   159                                  
   160 00000069 66B800000080                mov  eax,0x80000000
   161 0000006F 0FA2                        cpuid
   162 00000071 663D01000080                cmp  eax,0x80000001     ; is extended function 0x80000001 available?
   163 00000077 72E1                        jb   not64
   164                                  
   165 00000079 66B801000080                mov  eax,0x80000001
   166 0000007F 0FA2                        cpuid
   167 00000081 66F7C200000020              test edx, 1 << 29       ; test LM bit
   168 00000088 74D0                        jz   not64
   169                                  
   170                                      ; ---- setup 4KB paging tables
   171                                      ;           swdev3a s4.5 pg 4-25 fig 4-8
   172                                      ;           swdev3a s4.6 pg 4-23 fig 4-10
   173                                  
   174 0000008A 66BF00100000                mov  edi,pml4e          ; first pml4
   175 00000090 0F22DF                      mov  cr3,edi            ; install it in cr3
   176 00000093 66B807200000                mov  eax,pdpte + 7
   177 00000099 66AB                        stosd
   178 0000009B 6631C0                      xor  eax,eax
   179 0000009E 66B9FF030000                mov  ecx,0x400-1
   180 000000A4 F366AB                      rep  stosd
   181                                  
   182                                              ; assume pdpte physically follows pml4
   183                                  
   184 000000A7 66B807300000                mov  eax,pgdir + 7      ; next setup the pdpte
   185 000000AD 66AB                        stosd
   186 000000AF 6631C0                      xor  eax,eax
   187 000000B2 66B9FF030000                mov  ecx,0x400-1
   188 000000B8 F366AB                      rep  stosd
   189                                  
   190                                              ; assume pgdir physically follows pdpte
   191                                  
   192 000000BB 66B807400000                mov  eax,pgtb0 + 7      ; page table 0: present, pl=3, r/w
   193 000000C1 66AB                        stosd                   ; ... pl=3 for now (simplify vga access)
   194 000000C3 6631C0                      xor  eax,eax            ; invalidate the rest of the addr space
   195 000000C6 66B9FF030000                mov  ecx,0x400-1
   196 000000CC F366AB                      rep stosd
   197                                  
   198                                              ; assume pgtb0 physically follows pgdir
   199                                              ; pgtb0 is the page table for kernel memory
   200                                  
   201 000000CF 66AB                        stosd                   ; access to page 0 will always cause a fault
   202 000000D1 66AB                        stosd
   203 000000D3 6689C3                      mov  ebx,eax
   204 000000D6 66B803100000                mov  eax,0x1000 + 3     ; rest are direct map: present, pl=0, r/w
   205 000000DC 66B9FF010000                mov  ecx,0x200-1
   206                                  pgtb0_fill :
   207 000000E2 66AB                        stosd
   208 000000E4 6693                        xchg eax,ebx
   209 000000E6 66AB                        stosd
   210 000000E8 6693                        xchg eax,ebx
   211 000000EA 660500100000                add  eax,0x1000
   212 000000F0 E2F0                        loop pgtb0_fill
   213                                  
   214                                              ; enable paging and protected mode
   215                                  
   216 000000F2 66B8A0000000                mov  eax,0xa0
   217 000000F8 0F22E0                      mov  cr4,eax            ; set the pae and pge
   218                                  
   219 000000FB 66B9800000C0                mov ecx,0xc0000080      ; get the efer msr
   220 00000101 0F32                        rdmsr    
   221 00000103 660D00010000                or  eax,0x00000100      ; set lme
   222 00000109 0F30                        wrmsr
   223                                  
   224 0000010B 0F20C0                      mov eax,cr0
   225 0000010E 660D01000080                or  eax,0x80000001      ; enable paging and protected mode together
   226 00000114 0F22C0                      mov cr0,eax 
   227                                  
   228                                      ; ----
   229                                  
   230 00000117 0F0116[1800]                lgdt [gdtr]             ; initialize the gdt
   231 0000011C EA[2101]0800                jmp  codesel:flush_ip1  ; flush the cpu instruction pipeline
   232                                  flush_ip1: 
   233                                  bits 64                     ; instructions after this point are 64bit
   234                                  
   235 00000121 66B81000                    mov  ax,datasel   
   236 00000125 8ED8                        mov  ds,ax              ; initialize the data segments
   237 00000127 8EC0                        mov  es,ax
   238 00000129 8ED0                        mov  ss,ax
   239 0000012B 8EE0                        mov  fs,ax
   240 0000012D 8EE8                        mov  gs,ax
   241                                  
   242                                      ; ---- debug marker
   243 0000012F 65C6042501800B000A          mov  byte [gs:0xb8001],0xA    ; turn the first two chars green
   244 00000138 65C6042503800B000A          mov  byte [gs:0xb8003],0xA
   245                                  
   246                                      ; ---- setup interrupt handlers
   247                                  
   248                                  ;   mov  eax,int_handler_timer
   249                                  ;   mov  [idt+IRQA*8],ax
   250                                  ;   mov  word [idt+IRQA*8+2],codesel
   251                                  ;   mov  word [idt+IRQA*8+4],0x8E00
   252                                  ;   shr  eax,16
   253                                  ;   mov  [idt+IRQA*8+6],ax
   254                                  
   255                                  ;   mov  eax,int_handler_kbd
   256                                  ;   mov  [idt+IRQB*8],ax
   257                                  ;   mov  word [idt+IRQB*8+2],codesel
   258                                  ;   mov  word [idt+IRQB*8+4],0x8E00
   259                                  ;   shr  eax,16
   260                                  ;   mov  [idt+IRQB*8+6],ax
   261                                  
   262                                  ;   lidt [idtr]                     ; install the idt
   263                                  ;   mov  sp,kstack_size             ; initialize the stack
   264                                  
   265                                  
   266 00000141 FB                           sti
   267                                  idle :
   268 00000142 F4                          hlt                     ; wait for interrupts
   269 00000143 EBFD                        jmp  idle
   270                                  
   271                                  ; ----------------------------
   272                                  ;   puts_vga_rm - write a null delimited string to the VGA controller
   273                                  ;                  in real mode
   274                                  ;
   275                                  ;           esi - address of string
   276                                  ;           ebx - screen location (2 bytes per char, 160 bytes per line)
   277                                  ;           eax - destroyed
   278                                  ;            gs - destroyed
   279                                  bits 16
   280                                  
   281                                  puts_vga_rm :
   282 00000145 B800B8                      mov  ax,0xb800      ; point gs at video memory
   283 00000148 8EE8                        mov  gs,ax
   284                                  puts_vga_rm_loop :
   285 0000014A AC                          lodsb
   286 0000014B 3C00                        cmp  al,0
   287 0000014D 7409                        jz   puts_vga_rm_done
   288 0000014F 658807                      mov  [gs:bx],al
   289 00000152 6643                        inc  ebx
   290 00000154 6643                        inc  ebx
   291 00000156 EBF2                        jmp  puts_vga_rm_loop
   292                                  puts_vga_rm_done :
   293 00000158 C3                          ret
   294                                  
   295 00000159 90<rept>                align 8                     ; only need 4 but 8 looks nicer when debugging
   296                                  codesize equ ($-codestart)
   297                                  
   298                                  ; ---------------------------------------------------------
   299                                  section .data
   300                                  datastart :
   301                                  
   302                                  ; -------- descriptors --------------
   303                                  ; Intel SW dev manual 3a, 3.4.5, pg 103
   304                                  ;
   305                                  ; In my opinion, macros for descriptor entries
   306                                  ; don't make the code that much more readable.
   307                                  
   308                                  gdt :
   309                                  nullsel equ $-gdt           ; nullsel = 0h
   310 00000000 0000000000000000            dd 0,0                  ; first descriptor per convention is 0
   311                                  
   312                                  codesel equ $-gdt           ; codesel = 8h  4Gb flat over all logical mem
   313 00000008 0000                        dw 0x0000               ; limit 0-15
   314 0000000A 0000                        dw 0x0000               ; base  0-15
   315 0000000C 00                          db 0x00                 ; base 16-23
   316 0000000D 9A                          db 0x9a                 ; present, dpl=0, code e/r
   317 0000000E 20                          db 0x20                 ; 32bit, 4k granular, limit 16-19
   318 0000000F 00                          db 0x00                 ; base 24-31
   319                                  
   320                                  datasel equ $-gdt           ; datasel = 10h  4Gb flat over all logical mem
   321 00000010 0000                        dw 0x0000               ; limit 0-15
   322 00000012 0000                        dw 0x0000               ; base  0-15
   323 00000014 00                          db 0x00                 ; base 16-23
   324 00000015 92                          db 0x92                 ; present, dpl=0, data r/w
   325 00000016 00                          db 0x00                 ; 32bit, 4k granular, limit 16-19
   326 00000017 00                          db 0x00                 ; base 24-31
   327                                  
   328                                  gdt_end :
   329                                  
   330                                  gdtr :
   331 00000018 1700                        dw gdt_end - gdt - 1    ; gdt length
   332 0000001A [00000000]                  dd gdt                  ; gdt physical address
   333                                  
   334                                  idtr :
   335 0000001E 7F01                        dw idt_end - idt - 1    ; length of the idt
   336 00000020 00600000                    dd idt                  ; address of the idt
   337                                  
   338                                  
   339 00000024 4F5A2076302E30302E-     bootmsg     db      "OZ v0.00.64 - 2015/10/12",0
   340 0000002D 3634202D2032303135-
   341 00000036 2F31302F313200     
   342 0000003D 637075206E6F742036-     no64msg     db      "cpu not 64bit ",0
   343 00000046 346269742000       
   344                                  
   345 0000004C 00<rept>                times 446-codesize-($-$$)  db 0 ; Fill with zeros up to the partition table
   346                                  
   347                                  %ifdef USB
   348                                  ; a partition table for my 512MB USB stick
   349                                  db 0x80, 0x01, 0x01, 0, 0x06, 0x10, 0xe0, 0xbe, 0x20, 0, 0, 0, 0xe0, 0x7b, 0xf, 0
   350                                  db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   351                                  db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   352                                  db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   353                                  %else
   354                                              ; A default partition table that matches a 1.44MB floppy
   355 0000005E 800101000601124F                    db 0x80,0x01,0x01,0x00,0x06,0x01,0x12,0x4f
   356 00000066 120000002E0B0000                    db 0x12,0x00,0x00,0x00,0x2e,0x0b,0x00,0x00
   357 0000006E 000000000000000000-                 db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   358 00000077 00000000000000     
   359 0000007E 000000000000000000-                 db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   360 00000087 00000000000000     
   361 0000008E 000000000000000000-                 db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   362 00000097 00000000000000     
   363                                  %endif
   364                                  
   365                                  times 510-codesize-($-$$) db 0      ; fill with zeros up to MBR signature
   366                                  
   367 0000009E 55AA                                dw 0x0aa55      ; write aa55 in bytes 511,512 to indicate
   368                                                              ; that it is a boot sector. 
   369                                  
   370                                  pml4e equ 0x1000            ; use some of the free memory below us
   371                                  pdpte equ 0x2000            ; code above assumes this follows pml4e
   372                                  pgdir equ 0x3000            ; code above assumes this follows pdpte
   373                                  pgtb0 equ 0x4000            ; code above assumes this follows pgdir
   374                                  
   375                                  idt equ 0x6000
   376                                  idt_end equ idt+48*8        ; 32 sw + 16 remapped hw vectors
   377                                  
   378                                  kstack_loc  equ 0x7000
   379                                  kstack_size equ 1024
   380                                  
   381                                  datasize equ ($-datastart)
   382                                  
   383                                  kend :
