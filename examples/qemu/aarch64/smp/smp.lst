
smp.o:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000000000 <thd>:
    // function return value   :D
}

static int
thd(struct thread * th)
{
   0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   4:	910003fd 	mov	x29, sp
   8:	f9000bf3 	str	x19, [sp, #16]
   c:	aa0003f3 	mov	x19, x0

static inline u64
armv8_get_tp(void)
{
    u64 tp;
    asm volatile("mrs %0, tpidr_el0" : "=r" (tp) : : );
  10:	d53bd040 	mrs	x0, tpidr_el0
    printf("thread %d: cpu(%d) arg(%x)\n", th->thno, cpu_id(), th->arg0);
  14:	f9401263 	ldr	x3, [x19, #32]
  18:	b9400802 	ldr	w2, [x0, #8]
  1c:	f9400661 	ldr	x1, [x19, #8]
  20:	90000000 	adrp	x0, 0 <thd>
  24:	91000000 	add	x0, x0, #0x0
  28:	94000000 	bl	0 <printf>

//#if 0
    if (th->thno == 1) {
  2c:	f9400660 	ldr	x0, [x19, #8]
  30:	f100041f 	cmp	x0, #0x1
  34:	54000080 	b.eq	44 <thd+0x44>  // b.none
        printf("forcing a memory access exception on thread 1 ...\n");
        int * x = (void *)-1;
        printf("%x\n", *x);
    }
//#endif
}
  38:	f9400bf3 	ldr	x19, [sp, #16]
  3c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40:	d65f03c0 	ret
        printf("forcing a memory access exception on thread 1 ...\n");
  44:	90000000 	adrp	x0, 0 <thd>
  48:	91000000 	add	x0, x0, #0x0
  4c:	94000000 	bl	0 <printf>
        printf("%x\n", *x);
  50:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  54:	39400002 	ldrb	w2, [x0]
  58:	39400401 	ldrb	w1, [x0, #1]
  5c:	aa012042 	orr	x2, x2, x1, lsl #8
  60:	39400801 	ldrb	w1, [x0, #2]
  64:	aa014041 	orr	x1, x2, x1, lsl #16
  68:	39400c00 	ldrb	w0, [x0, #3]
  6c:	2a006021 	orr	w1, w1, w0, lsl #24
  70:	90000000 	adrp	x0, 0 <thd>
  74:	91000000 	add	x0, x0, #0x0
  78:	94000000 	bl	0 <printf>
  7c:	17ffffef 	b	38 <thd+0x38>

0000000000000080 <smp_newcpu>:
{
  80:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  84:	910003fd 	mov	x29, sp
  88:	f9000bf3 	str	x19, [sp, #16]
  8c:	aa0003f3 	mov	x19, x0
    armv8_set_tp(th->stack - 0x1000);
  90:	f9400000 	ldr	x0, [x0]
  94:	d1400400 	sub	x0, x0, #0x1, lsl #12
    asm volatile("msr tpidr_el0, %0" : : "r" (tp) : );
  98:	d51bd040 	msr	tpidr_el0, x0
    asm("mrs %0, currentel; lsr %0, %0, 2" : "=r" (status) : : );
  9c:	d5384242 	mrs	x2, currentel
  a0:	d342fc42 	lsr	x2, x2, #2
    asm volatile("mrs %0, tpidr_el0" : "=r" (tp) : : );
  a4:	d53bd043 	mrs	x3, tpidr_el0

static inline u64
armv8_get_sp(void)
{
    u64 sp;
    asm volatile("mov %0, sp"  : "=r" (sp) : );
  a8:	910003e4 	mov	x4, sp
    printf("smp%d: el%d tls(%x) sp(%x)\n", th->thno, armv8_get_el(),
  ac:	f9400661 	ldr	x1, [x19, #8]
  b0:	90000000 	adrp	x0, 0 <thd>
  b4:	91000000 	add	x0, x0, #0x0
  b8:	94000000 	bl	0 <printf>
    th->func(th);
  bc:	f9400e61 	ldr	x1, [x19, #24]
  c0:	aa1303e0 	mov	x0, x19
  c4:	d63f0020 	blr	x1
    asm volatile("wfi");        // low power sleep
  c8:	d503207f 	wfi
};
  cc:	f9400bf3 	ldr	x19, [sp, #16]
  d0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  d4:	d65f03c0 	ret

00000000000000d8 <smp_start_thread>:
{
  d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  dc:	910003fd 	mov	x29, sp
  e0:	a90153f3 	stp	x19, x20, [sp, #16]
  e4:	f90013f5 	str	x21, [sp, #32]
  e8:	aa0003f5 	mov	x21, x0
  ec:	aa0103f4 	mov	x20, x1
    int cpu = smp_next_cpu++;
  f0:	90000000 	adrp	x0, 0 <thd>
  f4:	b9400013 	ldr	w19, [x0]
  f8:	11000661 	add	w1, w19, #0x1
  fc:	b9000001 	str	w1, [x0]
    struct thread * th = (struct thread *)mem_alloc(pool4k, 1);
 100:	52800021 	mov	w1, #0x1                   	// #1
 104:	90000000 	adrp	x0, 8 <thd+0x8>
 108:	f9400000 	ldr	x0, [x0]
 10c:	94000000 	bl	0 <mem_alloc>
 110:	aa0003e4 	mov	x4, x0
    th->stack = (u64)th + 0x1000;
 114:	91400400 	add	x0, x0, #0x1, lsl #12
 118:	f9000080 	str	x0, [x4]
    th->func  = func;
 11c:	f9000c95 	str	x21, [x4, #24]
    th->thno  = cpu;
 120:	93407e60 	sxtw	x0, w19
 124:	f9000480 	str	x0, [x4, #8]
    th->arg0  = arg0;
 128:	f9001094 	str	x20, [x4, #32]
    asm volatile (
 12c:	58000520 	ldr	x0, 1d0 <smp_init+0x80>
 130:	aa1303e1 	mov	x1, x19
 134:	58000522 	ldr	x2, 1d8 <smp_init+0x88>
 138:	aa0403e3 	mov	x3, x4
 13c:	d4000002 	hvc	#0x0
}
 140:	a94153f3 	ldp	x19, x20, [sp, #16]
 144:	f94013f5 	ldr	x21, [sp, #32]
 148:	a8c37bfd 	ldp	x29, x30, [sp], #48
 14c:	d65f03c0 	ret

0000000000000150 <smp_init>:

void
smp_init(void)
{
 150:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 154:	910003fd 	mov	x29, sp
 158:	a90153f3 	stp	x19, x20, [sp, #16]
 15c:	f90013f5 	str	x21, [sp, #32]
    asm("mrs %0, currentel; lsr %0, %0, 2" : "=r" (status) : : );
 160:	d5384241 	mrs	x1, currentel
 164:	d342fc21 	lsr	x1, x1, #2
    asm volatile("mrs %0, tpidr_el0" : "=r" (tp) : : );
 168:	d53bd042 	mrs	x2, tpidr_el0
    asm volatile("mov %0, sp"  : "=r" (sp) : );
 16c:	910003e3 	mov	x3, sp
    // announce the boot thread
    printf("smp0: el%d tls(%x) sp(%x)\n", armv8_get_el(), armv8_get_tp(), armv8_get_sp());
 170:	90000000 	adrp	x0, 0 <thd>
 174:	91000000 	add	x0, x0, #0x0
 178:	94000000 	bl	0 <printf>
    // smp_start_thread() with a zero or greater cpu number does not yet
    // restart a cpu on the new thread ... until then smp_start_thread()
    // must be called from main() with a -1
    int n = 0;
    do {
        if (n++ >= MAX_CPUS-1) break;
 17c:	52800033 	mov	w19, #0x1                   	// #1
    } while (smp_start_thread(thd, (void *)((n << 4) | (u64)0xa)) == 0);
 180:	52800155 	mov	w21, #0xa                   	// #10
 184:	90000014 	adrp	x20, 0 <thd>
 188:	91000294 	add	x20, x20, #0x0
 18c:	2a1312a1 	orr	w1, w21, w19, lsl #4
 190:	93407c21 	sxtw	x1, w1
 194:	aa1403e0 	mov	x0, x20
 198:	94000000 	bl	d8 <smp_start_thread>
 19c:	35000080 	cbnz	w0, 1ac <smp_init+0x5c>
        if (n++ >= MAX_CPUS-1) break;
 1a0:	11000673 	add	w19, w19, #0x1
 1a4:	7100227f 	cmp	w19, #0x8
 1a8:	54ffff21 	b.ne	18c <smp_init+0x3c>  // b.any

    printf("smp_init complete %d cpus\n", n);
 1ac:	2a1303e1 	mov	w1, w19
 1b0:	90000000 	adrp	x0, 0 <thd>
 1b4:	91000000 	add	x0, x0, #0x0
 1b8:	94000000 	bl	0 <printf>
}
 1bc:	a94153f3 	ldp	x19, x20, [sp, #16]
 1c0:	f94013f5 	ldr	x21, [sp, #32]
 1c4:	a8c37bfd 	ldp	x29, x30, [sp], #48
 1c8:	d65f03c0 	ret
 1cc:	00000000 	.inst	0x00000000 ; undefined
 1d0:	c4000003 	.word	0xc4000003
	...
