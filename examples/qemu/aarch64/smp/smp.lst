
smp.o:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000000000 <thd>:
    return rc;
}

static int
thd(struct thread * th)
{
   0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   4:	910003fd 	mov	x29, sp
   8:	f9000bf3 	str	x19, [sp, #16]
   c:	aa0003f3 	mov	x19, x0

static inline u64
armv8_get_tp(void)
{
    u64 tp;
    asm volatile("mrs %0, tpidr_el0" : "=r" (tp) : : );
  10:	d53bd040 	mrs	x0, tpidr_el0
    printf("thread %d: cpu(%d) arg(%x)\n", th->thno, cpu_id(), th->arg0);
  14:	f9401263 	ldr	x3, [x19, #32]
  18:	b9400802 	ldr	w2, [x0, #8]
  1c:	f9400661 	ldr	x1, [x19, #8]
  20:	90000000 	adrp	x0, 0 <thd>
  24:	91000000 	add	x0, x0, #0x0
  28:	94000000 	bl	0 <printf>

//#if 0
    if (th->thno == 1) {
  2c:	f9400660 	ldr	x0, [x19, #8]
  30:	f100041f 	cmp	x0, #0x1
  34:	54000080 	b.eq	44 <thd+0x44>  // b.none
        printf("forcing a memory access exception on thread 1 ...\n");
        int * x = (void *)-1;
        printf("%x\n", *x);
    }
//#endif
}
  38:	f9400bf3 	ldr	x19, [sp, #16]
  3c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40:	d65f03c0 	ret
        printf("forcing a memory access exception on thread 1 ...\n");
  44:	90000000 	adrp	x0, 0 <thd>
  48:	91000000 	add	x0, x0, #0x0
  4c:	94000000 	bl	0 <printf>
        printf("%x\n", *x);
  50:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  54:	39400002 	ldrb	w2, [x0]
  58:	39400401 	ldrb	w1, [x0, #1]
  5c:	aa012042 	orr	x2, x2, x1, lsl #8
  60:	39400801 	ldrb	w1, [x0, #2]
  64:	aa014041 	orr	x1, x2, x1, lsl #16
  68:	39400c00 	ldrb	w0, [x0, #3]
  6c:	2a006021 	orr	w1, w1, w0, lsl #24
  70:	90000000 	adrp	x0, 0 <thd>
  74:	91000000 	add	x0, x0, #0x0
  78:	94000000 	bl	0 <printf>
  7c:	17ffffef 	b	38 <thd+0x38>

0000000000000080 <smp_newcpu>:
{
  80:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  84:	910003fd 	mov	x29, sp
  88:	f9000bf3 	str	x19, [sp, #16]
  8c:	aa0003f3 	mov	x19, x0
    armv8_set_tp(th->stack - 0x1000);
  90:	f9400000 	ldr	x0, [x0]
  94:	d1400400 	sub	x0, x0, #0x1, lsl #12
    asm volatile("msr tpidr_el0, %0" : : "r" (tp) : );
  98:	d51bd040 	msr	tpidr_el0, x0
    asm("mrs %0, currentel; lsr %0, %0, 2" : "=r" (status) : : );
  9c:	d5384242 	mrs	x2, currentel
  a0:	d342fc42 	lsr	x2, x2, #2
    asm volatile("mrs %0, tpidr_el0" : "=r" (tp) : : );
  a4:	d53bd043 	mrs	x3, tpidr_el0

static inline u64
armv8_get_sp(void)
{
    u64 sp;
    asm volatile("mov %0, sp"  : "=r" (sp) : );
  a8:	910003e4 	mov	x4, sp
    printf("smp%d: el%d tls(%x) sp(%x)\n", th->thno, armv8_get_el(),
  ac:	f9400661 	ldr	x1, [x19, #8]
  b0:	90000000 	adrp	x0, 0 <thd>
  b4:	91000000 	add	x0, x0, #0x0
  b8:	94000000 	bl	0 <printf>
    th->func(th);
  bc:	f9400e61 	ldr	x1, [x19, #24]
  c0:	aa1303e0 	mov	x0, x19
  c4:	d63f0020 	blr	x1
    asm volatile("wfi");        // low power sleep
  c8:	d503207f 	wfi
};
  cc:	f9400bf3 	ldr	x19, [sp, #16]
  d0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  d4:	d65f03c0 	ret

00000000000000d8 <smp_init>:

int
smp_init(void)
{
  d8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  dc:	910003fd 	mov	x29, sp
  e0:	a90153f3 	stp	x19, x20, [sp, #16]
  e4:	a9025bf5 	stp	x21, x22, [sp, #32]
  e8:	a90363f7 	stp	x23, x24, [sp, #48]
  ec:	f90023f9 	str	x25, [sp, #64]
    asm("mrs %0, currentel; lsr %0, %0, 2" : "=r" (status) : : );
  f0:	d5384241 	mrs	x1, currentel
  f4:	d342fc21 	lsr	x1, x1, #2
    asm volatile("mrs %0, tpidr_el0" : "=r" (tp) : : );
  f8:	d53bd042 	mrs	x2, tpidr_el0
    asm volatile("mov %0, sp"  : "=r" (sp) : );
  fc:	910003e3 	mov	x3, sp
    // announce the boot thread
    printf("smp0: el%d tls(%x) sp(%x)\n", armv8_get_el(), armv8_get_tp(), armv8_get_sp());
 100:	90000000 	adrp	x0, 0 <thd>
 104:	91000000 	add	x0, x0, #0x0
 108:	94000000 	bl	0 <printf>

    int n = 1;      // the boot cpu counts as 1
    while (smp_start_thread(thd, (void *)(u64)n) == 0)
 10c:	d2800034 	mov	x20, #0x1                   	// #1
    int cpu = smp_next_cpu++;
 110:	90000015 	adrp	x21, 0 <thd>
 114:	910002b5 	add	x21, x21, #0x0
    struct thread * th = (struct thread *)mem_alloc(pool4k, 1);
 118:	90000019 	adrp	x25, 0 <pool4k>
 11c:	52800038 	mov	w24, #0x1                   	// #1
    th->func  = func;
 120:	90000017 	adrp	x23, 0 <thd>
 124:	910002f7 	add	x23, x23, #0x0
 128:	2a1403f6 	mov	w22, w20
    int cpu = smp_next_cpu++;
 12c:	b94002b3 	ldr	w19, [x21]
 130:	11000660 	add	w0, w19, #0x1
 134:	b90002a0 	str	w0, [x21]
    struct thread * th = (struct thread *)mem_alloc(pool4k, 1);
 138:	2a1803e1 	mov	w1, w24
 13c:	f9400320 	ldr	x0, [x25]
 140:	94000000 	bl	0 <mem_alloc>
 144:	aa0003e4 	mov	x4, x0
    th->stack = (u64)th + 0x1000;
 148:	91400400 	add	x0, x0, #0x1, lsl #12
 14c:	f9000080 	str	x0, [x4]
    th->func  = func;
 150:	f9000c97 	str	x23, [x4, #24]
    th->thno  = cpu;
 154:	93407e60 	sxtw	x0, w19
 158:	f9000480 	str	x0, [x4, #8]
    th->arg0  = arg0;
 15c:	f9001094 	str	x20, [x4, #32]
    asm volatile (
 160:	580002c0 	ldr	x0, 1b8 <smp_init+0xe0>
 164:	aa1303e1 	mov	x1, x19
 168:	580002c2 	ldr	x2, 1c0 <smp_init+0xe8>
 16c:	aa0403e3 	mov	x3, x4
 170:	d4000002 	hvc	#0x0
 174:	aa0003e4 	mov	x4, x0
    while (smp_start_thread(thd, (void *)(u64)n) == 0)
 178:	350000a4 	cbnz	w4, 18c <smp_init+0xb4>
        if (++n >= MAX_CPUS)
 17c:	11000696 	add	w22, w20, #0x1
 180:	91000694 	add	x20, x20, #0x1
 184:	f100229f 	cmp	x20, #0x8
 188:	54fffd01 	b.ne	128 <smp_init+0x50>  // b.any
            break;

    printf("smp_init complete %d cpus\n", n);
 18c:	2a1603e1 	mov	w1, w22
 190:	90000000 	adrp	x0, 0 <thd>
 194:	91000000 	add	x0, x0, #0x0
 198:	94000000 	bl	0 <printf>

    return n;
}
 19c:	2a1603e0 	mov	w0, w22
 1a0:	a94153f3 	ldp	x19, x20, [sp, #16]
 1a4:	a9425bf5 	ldp	x21, x22, [sp, #32]
 1a8:	a94363f7 	ldp	x23, x24, [sp, #48]
 1ac:	f94023f9 	ldr	x25, [sp, #64]
 1b0:	a8c57bfd 	ldp	x29, x30, [sp], #80
 1b4:	d65f03c0 	ret
 1b8:	c4000003 	.word	0xc4000003
	...
